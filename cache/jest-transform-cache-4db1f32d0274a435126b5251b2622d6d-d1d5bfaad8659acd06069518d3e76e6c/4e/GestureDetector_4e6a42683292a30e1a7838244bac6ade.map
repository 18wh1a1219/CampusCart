{"version":3,"mappings":"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","names":["ALLOWED_PROPS","baseGestureHandlerWithMonitorProps","tapGestureHandlerProps","panGestureHandlerProps","panGestureHandlerCustomNativeProps","longPressGestureHandlerProps","forceTouchGestureHandlerProps","flingGestureHandlerProps","convertToHandlerTag","ref","BaseGesture","handlerTag","current","_ref$current","extractValidHandlerTags","interactionGroup","map","_interactionGroup$map2","filter","tag","dropHandlers","preparedGesture","config","handler","RNGestureHandlerModule","dropGestureHandler","attachHandlers","gestureConfig","gesture","viewTag","useAnimated","firstExecution","initialize","setImmediate","prepare","createGestureHandler","handlerName","requireToFail","simultaneousWith","updateGestureHandler","simultaneousHandlers","waitFor","attachGestureHandler","animatedHandlers","value","g","handlers","updateHandlers","i","length","needsToReattach","useAnimatedGesture","Reanimated","isStateChangeEvent","event","oldState","isTouchEvent","eventType","getHandler","type","CALLBACK_TYPE","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","EventType","UNDEFINED","runWorklet","isWorklet","args","console","warn","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","State","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","GestureStateManager","create","changeEventCalculator","_gesture$changeEventC","useEvent","animatedEventHandler","GestureDetector","props","toGestureArray","_gestureConfig$toGest2","find","reduce","prev","viewRef","firstRenderRef","React","useRef","Error","_react","AnimatedWrap","onGestureHandlerEvent","children","Wrap","render","child","Children","only","cloneElement","collapsable","Component","default","_Reanimated$default","createAnimatedComponent"],"sources":["GestureDetector.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport {\n  GestureType,\n  HandlerCallbacks,\n  BaseGesture,\n  GestureRef,\n  CALLBACK_TYPE,\n} from './gesture';\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\nimport {\n  baseGestureHandlerWithMonitorProps,\n  filterConfig,\n  findNodeHandle,\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from './gestureStateManager';\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\nimport {\n  panGestureHandlerProps,\n  panGestureHandlerCustomNativeProps,\n} from '../PanGestureHandler';\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\nimport { State } from '../../State';\nimport { EventType } from '../../EventType';\nimport { ComposedGesture } from './gestureComposition';\n\nconst ALLOWED_PROPS = [\n  ...baseGestureHandlerWithMonitorProps,\n  ...tapGestureHandlerProps,\n  ...panGestureHandlerProps,\n  ...panGestureHandlerCustomNativeProps,\n  ...longPressGestureHandlerProps,\n  ...forceTouchGestureHandlerProps,\n  ...flingGestureHandlerProps,\n];\n\nexport type GestureConfigReference = {\n  config: GestureType[];\n  animatedEventHandler: unknown;\n  animatedHandlers: SharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  > | null;\n  firstExecution: boolean;\n  useAnimated: boolean;\n};\n\nfunction convertToHandlerTag(ref: GestureRef): number {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    // @ts-ignore in this case it should be a ref either to gesture object or\n    // a gesture handler component, in both cases handlerTag property exists\n    return ref.current?.handlerTag ?? -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\n  return (\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\n  );\n}\n\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\n  for (const handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n\n    unregisterHandler(handler.handlerTag);\n  }\n}\n\ninterface AttachHandlersConfig {\n  preparedGesture: GestureConfigReference;\n  gestureConfig: ComposedGesture | GestureType | undefined;\n  gesture: GestureType[];\n  viewTag: number;\n  useAnimated: boolean;\n}\n\nfunction attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesture,\n  viewTag,\n  useAnimated,\n}: AttachHandlersConfig) {\n  if (!preparedGesture.firstExecution) {\n    gestureConfig?.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  // use setImmediate to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  setImmediate(() => {\n    gestureConfig?.prepare();\n  });\n\n  for (const handler of gesture) {\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler);\n\n    // use setImmediate to extract handlerTags, because all refs should be initialized\n    // when it's ran\n    setImmediate(() => {\n      let requireToFail: number[] = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      let simultaneousWith: number[] = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(\n          handler.config.simultaneousWith\n        );\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n    });\n  }\n  preparedGesture.config = gesture;\n\n  for (const gesture of preparedGesture.config) {\n    RNGestureHandlerModule.attachGestureHandler(\n      gesture.handlerTag,\n      viewTag,\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\n    );\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = (gesture.map(\n      (g) => g.handlers\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n  }\n}\n\nfunction updateHandlers(\n  preparedGesture: GestureConfigReference,\n  gestureConfig: ComposedGesture | GestureType | undefined,\n  gesture: GestureType[]\n) {\n  gestureConfig?.prepare();\n\n  for (let i = 0; i < gesture.length; i++) {\n    const handler = preparedGesture.config[i];\n\n    gesture[i].handlerTag = handler.handlerTag;\n    gesture[i].handlers.handlerTag = handler.handlerTag;\n  }\n\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  setImmediate(() => {\n    for (let i = 0; i < gesture.length; i++) {\n      const handler = preparedGesture.config[i];\n\n      handler.config = gesture[i].config;\n      handler.handlers = gesture[i].handlers;\n      handler.handlers.handlerTag = handler.handlerTag;\n\n      const requireToFail = extractValidHandlerTags(\n        handler.config.requireToFail\n      );\n\n      const simultaneousWith = extractValidHandlerTags(\n        handler.config.simultaneousWith\n      );\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n\n      registerHandler(handler.handlerTag, handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\n        (g) => g.handlers\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n    }\n  });\n}\n\nfunction needsToReattach(\n  preparedGesture: GestureConfigReference,\n  gesture: GestureType[]\n) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (let i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(preparedGesture: GestureConfigReference) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureStateChangeEvent {\n    'worklet';\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureTouchEvent {\n    'worklet';\n    return event.eventType != null;\n  }\n\n  function getHandler(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>\n  ) {\n    'worklet';\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\n    'worklet';\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>,\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n    ...args: any[]\n  ) {\n    'worklet';\n    const handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      // @ts-ignore Logic below makes sure the correct event is send to the\n      // correct handler.\n      handler?.(event, ...args);\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (\n            event.oldState === State.UNDETERMINED &&\n            event.state === State.BEGAN\n          ) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if (\n            (event.oldState === State.BEGAN ||\n              event.oldState === State.UNDETERMINED) &&\n            event.state === State.ACTIVE\n          ) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (\n            event.oldState !== event.state &&\n            event.state === State.END\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if (\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\n            event.state !== event.oldState\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(\n              touchEventTypeToCallbackType(event.eventType),\n              gesture,\n              event,\n              stateControllers[i]\n            );\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            runWorklet(\n              CALLBACK_TYPE.CHANGE,\n              gesture,\n              gesture.changeEventCalculator?.(\n                event,\n                lastUpdateEvent.value[gesture.handlerTag]\n              )\n            );\n\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    true\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\ninterface GestureDetectorProps {\n  gesture?: ComposedGesture | GestureType;\n}\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\n  props\n) => {\n  const gestureConfig = props.gesture;\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\n  const useAnimated =\n    gesture.find((gesture) =>\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\n    ) != null;\n  const viewRef = useRef(null);\n  const firstRenderRef = useRef(true);\n\n  const preparedGesture = React.useRef<GestureConfigReference>({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated,\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error(\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\n    );\n  }\n\n  if (preparedGesture.firstExecution) {\n    gestureConfig?.initialize?.();\n  }\n\n  if (useAnimated) {\n    // Whether animatedGesture or gesture is used shouldn't change\n    // during while an app is running\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAnimatedGesture(preparedGesture);\n  }\n\n  useEffect(() => {\n    firstRenderRef.current = true;\n    const viewTag = findNodeHandle(viewRef.current) as number;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesture,\n      viewTag,\n      useAnimated,\n    });\n\n    return () => {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!firstRenderRef.current) {\n      const viewTag = findNodeHandle(viewRef.current) as number;\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesture,\n          viewTag,\n          useAnimated,\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return (\n      <AnimatedWrap\n        ref={viewRef}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\n  }\n};\n\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\n  render() {\n    // I don't think that fighting with types over such a simple function is worth it\n    // The only thing it does is add 'collapsable: false' to the child component\n    // to make sure it is in the native view hierarchy so the detector can find\n    // correct viewTag to attach to.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const child: any = React.Children.only(this.props.children);\n\n    return React.cloneElement(\n      child,\n      { collapsable: false },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      child.props.children\n    );\n  }\n}\n\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\n"]}