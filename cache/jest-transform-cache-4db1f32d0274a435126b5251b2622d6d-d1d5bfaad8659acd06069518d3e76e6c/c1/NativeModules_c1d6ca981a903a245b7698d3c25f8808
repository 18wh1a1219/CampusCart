8241ab51d3d35c4ffe7e6ef3e9f31514
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var BatchedBridge = require('./BatchedBridge');

var invariant = require('invariant');

function genModule(config, moduleID) {
  if (!config) {
    return null;
  }

  var _config = (0, _slicedToArray2.default)(config, 5),
      moduleName = _config[0],
      constants = _config[1],
      methods = _config[2],
      promiseMethods = _config[3],
      syncMethods = _config[4];

  invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), "Module name prefixes should've been stripped by the native side " + "but wasn't for " + moduleName);

  if (!constants && !methods) {
    return {
      name: moduleName
    };
  }

  var module = {};
  methods && methods.forEach(function (methodName, methodID) {
    var isPromise = promiseMethods && arrayContains(promiseMethods, methodID) || false;
    var isSync = syncMethods && arrayContains(syncMethods, methodID) || false;
    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');
    var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';
    module[methodName] = genMethod(moduleID, methodID, methodType);
  });
  (0, _extends2.default)(module, constants);

  if (module.getConstants == null) {
    module.getConstants = function () {
      return constants || Object.freeze({});
    };
  } else {
    console.warn("Unable to define method 'getConstants()' on NativeModule '" + moduleName + "'. NativeModule '" + moduleName + "' already has a constant or method called 'getConstants'. Please remove it.");
  }

  if (__DEV__) {
    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);
  }

  return {
    name: moduleName,
    module: module
  };
}

global.__fbGenNativeModule = genModule;

function loadModule(name, moduleID) {
  invariant(global.nativeRequireModuleConfig, "Can't lazily create module without nativeRequireModuleConfig");
  var config = global.nativeRequireModuleConfig(name);
  var info = genModule(config, moduleID);
  return info && info.module;
}

function genMethod(moduleID, methodID, type) {
  var fn = null;

  if (type === 'promise') {
    fn = function promiseMethodWrapper() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var enqueueingFrameError = new Error();
      return new Promise(function (resolve, reject) {
        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, function (data) {
          return resolve(data);
        }, function (errorData) {
          return reject(updateErrorWithErrorData(errorData, enqueueingFrameError));
        });
      });
    };
  } else {
    fn = function nonPromiseMethodWrapper() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var lastArg = args.length > 0 ? args[args.length - 1] : null;
      var secondLastArg = args.length > 1 ? args[args.length - 2] : null;
      var hasSuccessCallback = typeof lastArg === 'function';
      var hasErrorCallback = typeof secondLastArg === 'function';
      hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');
      var onSuccess = hasSuccessCallback ? lastArg : null;
      var onFail = hasErrorCallback ? secondLastArg : null;
      var callbackCount = hasSuccessCallback + hasErrorCallback;
      var newArgs = args.slice(0, args.length - callbackCount);

      if (type === 'sync') {
        return BatchedBridge.callNativeSyncHook(moduleID, methodID, newArgs, onFail, onSuccess);
      } else {
        BatchedBridge.enqueueNativeCall(moduleID, methodID, newArgs, onFail, onSuccess);
      }
    };
  }

  fn.type = type;
  return fn;
}

function arrayContains(array, value) {
  return array.indexOf(value) !== -1;
}

function updateErrorWithErrorData(errorData, error) {
  return (0, _extends2.default)(error, errorData || {});
}

var NativeModules = {};

if (global.nativeModuleProxy) {
  NativeModules = global.nativeModuleProxy;
} else if (!global.nativeExtensions) {
  var bridgeConfig = global.__fbBatchedBridgeConfig;
  invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');

  var defineLazyObjectProperty = require('../Utilities/defineLazyObjectProperty');

  (bridgeConfig.remoteModuleConfig || []).forEach(function (config, moduleID) {
    var info = genModule(config, moduleID);

    if (!info) {
      return;
    }

    if (info.module) {
      NativeModules[info.name] = info.module;
    } else {
      defineLazyObjectProperty(NativeModules, info.name, {
        get: function get() {
          return loadModule(info.name, moduleID);
        }
      });
    }
  });
}

module.exports = NativeModules;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCYXRjaGVkQnJpZGdlIiwicmVxdWlyZSIsImludmFyaWFudCIsImdlbk1vZHVsZSIsImNvbmZpZyIsIm1vZHVsZUlEIiwibW9kdWxlTmFtZSIsImNvbnN0YW50cyIsIm1ldGhvZHMiLCJwcm9taXNlTWV0aG9kcyIsInN5bmNNZXRob2RzIiwic3RhcnRzV2l0aCIsIm5hbWUiLCJtb2R1bGUiLCJmb3JFYWNoIiwibWV0aG9kTmFtZSIsIm1ldGhvZElEIiwiaXNQcm9taXNlIiwiYXJyYXlDb250YWlucyIsImlzU3luYyIsIm1ldGhvZFR5cGUiLCJnZW5NZXRob2QiLCJnZXRDb25zdGFudHMiLCJPYmplY3QiLCJmcmVlemUiLCJjb25zb2xlIiwid2FybiIsIl9fREVWX18iLCJjcmVhdGVEZWJ1Z0xvb2t1cCIsImdsb2JhbCIsIl9fZmJHZW5OYXRpdmVNb2R1bGUiLCJsb2FkTW9kdWxlIiwibmF0aXZlUmVxdWlyZU1vZHVsZUNvbmZpZyIsImluZm8iLCJ0eXBlIiwiZm4iLCJwcm9taXNlTWV0aG9kV3JhcHBlciIsImFyZ3MiLCJlbnF1ZXVlaW5nRnJhbWVFcnJvciIsIkVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlbnF1ZXVlTmF0aXZlQ2FsbCIsImRhdGEiLCJlcnJvckRhdGEiLCJ1cGRhdGVFcnJvcldpdGhFcnJvckRhdGEiLCJub25Qcm9taXNlTWV0aG9kV3JhcHBlciIsImxhc3RBcmciLCJsZW5ndGgiLCJzZWNvbmRMYXN0QXJnIiwiaGFzU3VjY2Vzc0NhbGxiYWNrIiwiaGFzRXJyb3JDYWxsYmFjayIsIm9uU3VjY2VzcyIsIm9uRmFpbCIsImNhbGxiYWNrQ291bnQiLCJuZXdBcmdzIiwic2xpY2UiLCJjYWxsTmF0aXZlU3luY0hvb2siLCJhcnJheSIsInZhbHVlIiwiaW5kZXhPZiIsImVycm9yIiwiTmF0aXZlTW9kdWxlcyIsIm5hdGl2ZU1vZHVsZVByb3h5IiwibmF0aXZlRXh0ZW5zaW9ucyIsImJyaWRnZUNvbmZpZyIsIl9fZmJCYXRjaGVkQnJpZGdlQ29uZmlnIiwiZGVmaW5lTGF6eU9iamVjdFByb3BlcnR5IiwicmVtb3RlTW9kdWxlQ29uZmlnIiwiZ2V0IiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIk5hdGl2ZU1vZHVsZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmb3JtYXRcbiAqIEBmbG93IHN0cmljdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmF0Y2hlZEJyaWRnZSA9IHJlcXVpcmUoJy4vQmF0Y2hlZEJyaWRnZScpO1xuXG5jb25zdCBpbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxuaW1wb3J0IHR5cGUge0V4dGVuZGVkRXJyb3J9IGZyb20gJy4uL0NvcmUvRXh0ZW5kZWRFcnJvcic7XG5cbmV4cG9ydCB0eXBlIE1vZHVsZUNvbmZpZyA9IFtcbiAgc3RyaW5nIC8qIG5hbWUgKi8sXG4gID97Li4ufSAvKiBjb25zdGFudHMgKi8sXG4gID8kUmVhZE9ubHlBcnJheTxzdHJpbmc+IC8qIGZ1bmN0aW9ucyAqLyxcbiAgPyRSZWFkT25seUFycmF5PG51bWJlcj4gLyogcHJvbWlzZSBtZXRob2QgSURzICovLFxuICA/JFJlYWRPbmx5QXJyYXk8bnVtYmVyPiAvKiBzeW5jIG1ldGhvZCBJRHMgKi8sXG5dO1xuXG5leHBvcnQgdHlwZSBNZXRob2RUeXBlID0gJ2FzeW5jJyB8ICdwcm9taXNlJyB8ICdzeW5jJztcblxuZnVuY3Rpb24gZ2VuTW9kdWxlKFxuICBjb25maWc6ID9Nb2R1bGVDb25maWcsXG4gIG1vZHVsZUlEOiBudW1iZXIsXG4pOiA/e1xuICBuYW1lOiBzdHJpbmcsXG4gIG1vZHVsZT86IHsuLi59LFxuICAuLi5cbn0ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgW21vZHVsZU5hbWUsIGNvbnN0YW50cywgbWV0aG9kcywgcHJvbWlzZU1ldGhvZHMsIHN5bmNNZXRob2RzXSA9IGNvbmZpZztcbiAgaW52YXJpYW50KFxuICAgICFtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ1JDVCcpICYmICFtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ1JLJyksXG4gICAgXCJNb2R1bGUgbmFtZSBwcmVmaXhlcyBzaG91bGQndmUgYmVlbiBzdHJpcHBlZCBieSB0aGUgbmF0aXZlIHNpZGUgXCIgK1xuICAgICAgXCJidXQgd2Fzbid0IGZvciBcIiArXG4gICAgICBtb2R1bGVOYW1lLFxuICApO1xuXG4gIGlmICghY29uc3RhbnRzICYmICFtZXRob2RzKSB7XG4gICAgLy8gTW9kdWxlIGNvbnRlbnRzIHdpbGwgYmUgZmlsbGVkIGluIGxhemlseSBsYXRlclxuICAgIHJldHVybiB7bmFtZTogbW9kdWxlTmFtZX07XG4gIH1cblxuICBjb25zdCBtb2R1bGUgPSB7fTtcbiAgbWV0aG9kcyAmJlxuICAgIG1ldGhvZHMuZm9yRWFjaCgobWV0aG9kTmFtZSwgbWV0aG9kSUQpID0+IHtcbiAgICAgIGNvbnN0IGlzUHJvbWlzZSA9XG4gICAgICAgIChwcm9taXNlTWV0aG9kcyAmJiBhcnJheUNvbnRhaW5zKHByb21pc2VNZXRob2RzLCBtZXRob2RJRCkpIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXNTeW5jID1cbiAgICAgICAgKHN5bmNNZXRob2RzICYmIGFycmF5Q29udGFpbnMoc3luY01ldGhvZHMsIG1ldGhvZElEKSkgfHwgZmFsc2U7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgICFpc1Byb21pc2UgfHwgIWlzU3luYyxcbiAgICAgICAgJ0Nhbm5vdCBoYXZlIGEgbWV0aG9kIHRoYXQgaXMgYm90aCBhc3luYyBhbmQgYSBzeW5jIGhvb2snLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1ldGhvZFR5cGUgPSBpc1Byb21pc2UgPyAncHJvbWlzZScgOiBpc1N5bmMgPyAnc3luYycgOiAnYXN5bmMnO1xuICAgICAgbW9kdWxlW21ldGhvZE5hbWVdID0gZ2VuTWV0aG9kKG1vZHVsZUlELCBtZXRob2RJRCwgbWV0aG9kVHlwZSk7XG4gICAgfSk7XG5cbiAgT2JqZWN0LmFzc2lnbihtb2R1bGUsIGNvbnN0YW50cyk7XG5cbiAgaWYgKG1vZHVsZS5nZXRDb25zdGFudHMgPT0gbnVsbCkge1xuICAgIG1vZHVsZS5nZXRDb25zdGFudHMgPSAoKSA9PiBjb25zdGFudHMgfHwgT2JqZWN0LmZyZWV6ZSh7fSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFVuYWJsZSB0byBkZWZpbmUgbWV0aG9kICdnZXRDb25zdGFudHMoKScgb24gTmF0aXZlTW9kdWxlICcke21vZHVsZU5hbWV9Jy4gTmF0aXZlTW9kdWxlICcke21vZHVsZU5hbWV9JyBhbHJlYWR5IGhhcyBhIGNvbnN0YW50IG9yIG1ldGhvZCBjYWxsZWQgJ2dldENvbnN0YW50cycuIFBsZWFzZSByZW1vdmUgaXQuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBCYXRjaGVkQnJpZGdlLmNyZWF0ZURlYnVnTG9va3VwKG1vZHVsZUlELCBtb2R1bGVOYW1lLCBtZXRob2RzKTtcbiAgfVxuXG4gIHJldHVybiB7bmFtZTogbW9kdWxlTmFtZSwgbW9kdWxlfTtcbn1cblxuLy8gZXhwb3J0IHRoaXMgbWV0aG9kIGFzIGEgZ2xvYmFsIHNvIHdlIGNhbiBjYWxsIGl0IGZyb20gbmF0aXZlXG5nbG9iYWwuX19mYkdlbk5hdGl2ZU1vZHVsZSA9IGdlbk1vZHVsZTtcblxuZnVuY3Rpb24gbG9hZE1vZHVsZShuYW1lOiBzdHJpbmcsIG1vZHVsZUlEOiBudW1iZXIpOiA/ey4uLn0ge1xuICBpbnZhcmlhbnQoXG4gICAgZ2xvYmFsLm5hdGl2ZVJlcXVpcmVNb2R1bGVDb25maWcsXG4gICAgXCJDYW4ndCBsYXppbHkgY3JlYXRlIG1vZHVsZSB3aXRob3V0IG5hdGl2ZVJlcXVpcmVNb2R1bGVDb25maWdcIixcbiAgKTtcbiAgY29uc3QgY29uZmlnID0gZ2xvYmFsLm5hdGl2ZVJlcXVpcmVNb2R1bGVDb25maWcobmFtZSk7XG4gIGNvbnN0IGluZm8gPSBnZW5Nb2R1bGUoY29uZmlnLCBtb2R1bGVJRCk7XG4gIHJldHVybiBpbmZvICYmIGluZm8ubW9kdWxlO1xufVxuXG5mdW5jdGlvbiBnZW5NZXRob2QobW9kdWxlSUQ6IG51bWJlciwgbWV0aG9kSUQ6IG51bWJlciwgdHlwZTogTWV0aG9kVHlwZSkge1xuICBsZXQgZm4gPSBudWxsO1xuICBpZiAodHlwZSA9PT0gJ3Byb21pc2UnKSB7XG4gICAgZm4gPSBmdW5jdGlvbiBwcm9taXNlTWV0aG9kV3JhcHBlciguLi5hcmdzOiBBcnJheTxtaXhlZD4pIHtcbiAgICAgIC8vIEluIGNhc2Ugd2UgcmVqZWN0LCBjYXB0dXJlIGEgdXNlZnVsIHN0YWNrIHRyYWNlIGhlcmUuXG4gICAgICAvKiAkRmxvd0ZpeE1lW2NsYXNzLW9iamVjdC1zdWJ0eXBpbmddIGFkZGVkIHdoZW4gaW1wcm92aW5nIHR5cGluZyBmb3JcbiAgICAgICAqIHRoaXMgcGFyYW1ldGVycyAqL1xuICAgICAgY29uc3QgZW5xdWV1ZWluZ0ZyYW1lRXJyb3I6IEV4dGVuZGVkRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIEJhdGNoZWRCcmlkZ2UuZW5xdWV1ZU5hdGl2ZUNhbGwoXG4gICAgICAgICAgbW9kdWxlSUQsXG4gICAgICAgICAgbWV0aG9kSUQsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBkYXRhID0+IHJlc29sdmUoZGF0YSksXG4gICAgICAgICAgZXJyb3JEYXRhID0+XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIHVwZGF0ZUVycm9yV2l0aEVycm9yRGF0YShcbiAgICAgICAgICAgICAgICAoZXJyb3JEYXRhOiAkRmxvd0ZpeE1lKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlaW5nRnJhbWVFcnJvcixcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZuID0gZnVuY3Rpb24gbm9uUHJvbWlzZU1ldGhvZFdyYXBwZXIoLi4uYXJnczogQXJyYXk8bWl4ZWQ+KSB7XG4gICAgICBjb25zdCBsYXN0QXJnID0gYXJncy5sZW5ndGggPiAwID8gYXJnc1thcmdzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgIGNvbnN0IHNlY29uZExhc3RBcmcgPSBhcmdzLmxlbmd0aCA+IDEgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgICAgY29uc3QgaGFzU3VjY2Vzc0NhbGxiYWNrID0gdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbic7XG4gICAgICBjb25zdCBoYXNFcnJvckNhbGxiYWNrID0gdHlwZW9mIHNlY29uZExhc3RBcmcgPT09ICdmdW5jdGlvbic7XG4gICAgICBoYXNFcnJvckNhbGxiYWNrICYmXG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBoYXNTdWNjZXNzQ2FsbGJhY2ssXG4gICAgICAgICAgJ0Nhbm5vdCBoYXZlIGEgbm9uLWZ1bmN0aW9uIGFyZyBhZnRlciBhIGZ1bmN0aW9uIGFyZy4nLFxuICAgICAgICApO1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICAgIGNvbnN0IG9uU3VjY2VzczogPyhtaXhlZCkgPT4gdm9pZCA9IGhhc1N1Y2Nlc3NDYWxsYmFjayA/IGxhc3RBcmcgOiBudWxsO1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICAgIGNvbnN0IG9uRmFpbDogPyhtaXhlZCkgPT4gdm9pZCA9IGhhc0Vycm9yQ2FsbGJhY2sgPyBzZWNvbmRMYXN0QXJnIDogbnVsbDtcbiAgICAgIGNvbnN0IGNhbGxiYWNrQ291bnQgPSBoYXNTdWNjZXNzQ2FsbGJhY2sgKyBoYXNFcnJvckNhbGxiYWNrO1xuICAgICAgY29uc3QgbmV3QXJncyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSBjYWxsYmFja0NvdW50KTtcbiAgICAgIGlmICh0eXBlID09PSAnc3luYycpIHtcbiAgICAgICAgcmV0dXJuIEJhdGNoZWRCcmlkZ2UuY2FsbE5hdGl2ZVN5bmNIb29rKFxuICAgICAgICAgIG1vZHVsZUlELFxuICAgICAgICAgIG1ldGhvZElELFxuICAgICAgICAgIG5ld0FyZ3MsXG4gICAgICAgICAgb25GYWlsLFxuICAgICAgICAgIG9uU3VjY2VzcyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEJhdGNoZWRCcmlkZ2UuZW5xdWV1ZU5hdGl2ZUNhbGwoXG4gICAgICAgICAgbW9kdWxlSUQsXG4gICAgICAgICAgbWV0aG9kSUQsXG4gICAgICAgICAgbmV3QXJncyxcbiAgICAgICAgICBvbkZhaWwsXG4gICAgICAgICAgb25TdWNjZXNzLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZm4udHlwZSA9IHR5cGU7XG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gYXJyYXlDb250YWluczxUPihhcnJheTogJFJlYWRPbmx5QXJyYXk8VD4sIHZhbHVlOiBUKTogYm9vbGVhbiB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVycm9yV2l0aEVycm9yRGF0YShcbiAgZXJyb3JEYXRhOiB7bWVzc2FnZTogc3RyaW5nLCAuLi59LFxuICBlcnJvcjogRXh0ZW5kZWRFcnJvcixcbik6IEV4dGVuZGVkRXJyb3Ige1xuICAvKiAkRmxvd0ZpeE1lW2NsYXNzLW9iamVjdC1zdWJ0eXBpbmddIGFkZGVkIHdoZW4gaW1wcm92aW5nIHR5cGluZyBmb3IgdGhpc1xuICAgKiBwYXJhbWV0ZXJzICovXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGVycm9yLCBlcnJvckRhdGEgfHwge30pO1xufVxuXG5sZXQgTmF0aXZlTW9kdWxlczoge1ttb2R1bGVOYW1lOiBzdHJpbmddOiAkRmxvd0ZpeE1lLCAuLi59ID0ge307XG5pZiAoZ2xvYmFsLm5hdGl2ZU1vZHVsZVByb3h5KSB7XG4gIE5hdGl2ZU1vZHVsZXMgPSBnbG9iYWwubmF0aXZlTW9kdWxlUHJveHk7XG59IGVsc2UgaWYgKCFnbG9iYWwubmF0aXZlRXh0ZW5zaW9ucykge1xuICBjb25zdCBicmlkZ2VDb25maWcgPSBnbG9iYWwuX19mYkJhdGNoZWRCcmlkZ2VDb25maWc7XG4gIGludmFyaWFudChcbiAgICBicmlkZ2VDb25maWcsXG4gICAgJ19fZmJCYXRjaGVkQnJpZGdlQ29uZmlnIGlzIG5vdCBzZXQsIGNhbm5vdCBpbnZva2UgbmF0aXZlIG1vZHVsZXMnLFxuICApO1xuXG4gIGNvbnN0IGRlZmluZUxhenlPYmplY3RQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL1V0aWxpdGllcy9kZWZpbmVMYXp5T2JqZWN0UHJvcGVydHknKTtcbiAgKGJyaWRnZUNvbmZpZy5yZW1vdGVNb2R1bGVDb25maWcgfHwgW10pLmZvckVhY2goXG4gICAgKGNvbmZpZzogTW9kdWxlQ29uZmlnLCBtb2R1bGVJRDogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBJbml0aWFsbHkgdGhpcyBjb25maWcgd2lsbCBvbmx5IGNvbnRhaW4gdGhlIG1vZHVsZSBuYW1lIHdoZW4gcnVubmluZyBpbiBKU0MuIFRoZSBhY3R1YWxcbiAgICAgIC8vIGNvbmZpZ3VyYXRpb24gb2YgdGhlIG1vZHVsZSB3aWxsIGJlIGxhemlseSBsb2FkZWQuXG4gICAgICBjb25zdCBpbmZvID0gZ2VuTW9kdWxlKGNvbmZpZywgbW9kdWxlSUQpO1xuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZm8ubW9kdWxlKSB7XG4gICAgICAgIE5hdGl2ZU1vZHVsZXNbaW5mby5uYW1lXSA9IGluZm8ubW9kdWxlO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlcmUncyBubyBtb2R1bGUgY29uZmlnLCBkZWZpbmUgYSBsYXp5IGdldHRlclxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlZmluZUxhenlPYmplY3RQcm9wZXJ0eShOYXRpdmVNb2R1bGVzLCBpbmZvLm5hbWUsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGxvYWRNb2R1bGUoaW5mby5uYW1lLCBtb2R1bGVJRCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmF0aXZlTW9kdWxlcztcbiJdLCJtYXBwaW5ncyI6IkFBVUE7Ozs7Ozs7O0FBRUEsSUFBTUEsYUFBYSxHQUFHQyxPQUFPLENBQUMsaUJBQUQsQ0FBN0I7O0FBRUEsSUFBTUMsU0FBUyxHQUFHRCxPQUFPLENBQUMsV0FBRCxDQUF6Qjs7QUFjQSxTQUFTRSxTQUFULENBQ0VDLE1BREYsRUFFRUMsUUFGRixFQU9FO0VBQ0EsSUFBSSxDQUFDRCxNQUFMLEVBQWE7SUFDWCxPQUFPLElBQVA7RUFDRDs7RUFFRCwyQ0FBc0VBLE1BQXRFO0VBQUEsSUFBT0UsVUFBUDtFQUFBLElBQW1CQyxTQUFuQjtFQUFBLElBQThCQyxPQUE5QjtFQUFBLElBQXVDQyxjQUF2QztFQUFBLElBQXVEQyxXQUF2RDs7RUFDQVIsU0FBUyxDQUNQLENBQUNJLFVBQVUsQ0FBQ0ssVUFBWCxDQUFzQixLQUF0QixDQUFELElBQWlDLENBQUNMLFVBQVUsQ0FBQ0ssVUFBWCxDQUFzQixJQUF0QixDQUQzQixFQUVQLHFFQUNFLGlCQURGLEdBRUVMLFVBSkssQ0FBVDs7RUFPQSxJQUFJLENBQUNDLFNBQUQsSUFBYyxDQUFDQyxPQUFuQixFQUE0QjtJQUUxQixPQUFPO01BQUNJLElBQUksRUFBRU47SUFBUCxDQUFQO0VBQ0Q7O0VBRUQsSUFBTU8sTUFBTSxHQUFHLEVBQWY7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